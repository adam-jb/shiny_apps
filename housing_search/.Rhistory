MAINS_GAS_FLAG = case_when(MAINS_GAS_FLAG=="Y"~1,T~0))
names(df)
df <- df %>% mutate(PROPERTY_TYPE = case_when(PROPERTY_TYPE %in% c("Bungalow", "House") ~ 1, T~0 ),
MAINS_GAS_FLAG = case_when(MAINS_GAS_FLAG=="Y"~1,T~0))
## normalising columns
normalise <- function(x) {(x-min(x,na.rm=T))/(max(x,na.rm=T)-min(x,na.rm=T))}
normalised_matrix <- df%>%select(columns_user_may_care_about) %>%
mutate_all(normalise) %>%
mutate(
`Drive to central London (hours)` = `Drive to central London (hours)` * 0.3  # reducing weight of this as small input weight goes a long way
) %>%
mutate(  # making all missing values have meaning
`Noise levels` = case_when(is.na(`Noise levels`)~0,T~`Noise levels`), # missing data means quieter roads
`Bigger houses` = case_when(is.na(`Bigger houses`)~0,T~`Bigger houses`), # missing means small house
`House not flat` = case_when(is.na(`House not flat`)~0,T~`House not flat`) # missing means is flat
)
names(df)
normalised_matrix <- df%>%select(columns_user_may_care_about) %>%
mutate_all(normalise) %>%
mutate(
`Drive to central London (hours)` = `Drive to central London (hours)` * 0.3  # reducing weight of this as small input weight goes a long way
) %>%
mutate(  # making all missing values have meaning
`Noise levels` = case_when(is.na(`Noise levels`)~0,T~`Noise levels`), # missing data means quieter roads
`Bigger houses` = case_when(is.na(`Bigger houses`)~0,T~`Bigger houses`), # missing means small house
`House not flat` = case_when(is.na(`House not flat`)~0,T~`House not flat`) # missing means is flat
) %>%
mutate( # inverting scores so higher is always better
Flooding = 1 - flood_areas_count,
`Drive to central London (hours)` = 1 - `Drive to central London (hours)`,
`Noise levels` = 1 - `Noise levels`,
Price = 1 - Price
) %>%
data.matrix()  # matrix for faster computation
## making all columns numeric
df <- df %>% mutate(PROPERTY_TYPE = case_when(PROPERTY_TYPE %in% c("Bungalow", "House") ~ 1, T~0 ),
MAINS_GAS_FLAG = case_when(MAINS_GAS_FLAG=="Y"~1,T~0))
## normalising columns
normalise <- function(x) {(x-min(x,na.rm=T))/(max(x,na.rm=T)-min(x,na.rm=T))}
normalised_matrix <- df%>%select(columns_user_may_care_about) %>%
mutate_all(normalise) %>%
mutate(
`Drive to central London (hours)` = `Drive to central London (hours)` * 0.3  # reducing weight of this as small input weight goes a long way
) %>%
mutate(  # making all missing values have meaning
`Noise levels` = case_when(is.na(`Noise levels`)~0,T~`Noise levels`), # missing data means quieter roads
`Bigger houses` = case_when(is.na(`Bigger houses`)~0,T~`Bigger houses`), # missing means small house
`House not flat` = case_when(is.na(`House not flat`)~0,T~`House not flat`) # missing means is flat
) %>%
mutate( # inverting scores so higher is always better
Flooding = 1 - flood_areas_count,
`Drive to central London (hours)` = 1 - `Drive to central London (hours)`,
`Noise levels` = 1 - `Noise levels`,
Price = 1 - Price
) %>%
data.matrix()  # matrix for faster computation
normalised_matrix <- df%>%select(columns_user_may_care_about) %>%
mutate_all(normalise) %>%
mutate(
`Drive to central London (hours)` = `Drive to central London (hours)` * 0.3  # reducing weight of this as small input weight goes a long way
) %>%
mutate(  # making all missing values have meaning
`Noise levels` = case_when(is.na(`Noise levels`)~0,T~`Noise levels`), # missing data means quieter roads
`Bigger houses` = case_when(is.na(`Bigger houses`)~0,T~`Bigger houses`), # missing means small house
`House not flat` = case_when(is.na(`House not flat`)~0,T~`House not flat`) # missing means is flat
)
names(normalised_matrix)
df <- df %>% mutate(PROPERTY_TYPE = case_when(PROPERTY_TYPE %in% c("Bungalow", "House") ~ 1, T~0 ),
MAINS_GAS_FLAG = case_when(MAINS_GAS_FLAG=="Y"~1,T~0))
## normalising columns
normalise <- function(x) {(x-min(x,na.rm=T))/(max(x,na.rm=T)-min(x,na.rm=T))}
normalised_matrix <- df%>%select(columns_user_may_care_about) %>%
mutate_all(normalise) %>%
mutate(
`Drive to central London (hours)` = `Drive to central London (hours)` * 0.3  # reducing weight of this as small input weight goes a long way
) %>%
mutate(  # making all missing values have meaning
`Noise levels` = case_when(is.na(`Noise levels`)~0,T~`Noise levels`), # missing data means quieter roads
`Bigger houses` = case_when(is.na(`Bigger houses`)~0,T~`Bigger houses`), # missing means small house
`House not flat` = case_when(is.na(`House not flat`)~0,T~`House not flat`) # missing means is flat
) %>%
mutate( # inverting scores so higher is always better
`Flood risk` = 1 - `Flood risk`,
`Drive to central London (hours)` = 1 - `Drive to central London (hours)`,
`Noise levels` = 1 - `Noise levels`,
Price = 1 - Price
) %>%
data.matrix()  # matrix for faster computation
runApp()
runApp()
runApp()
runApp()
?userBox
?html
?HTML
runApp()
runApp()
runApp()
runApp()
remDr <- remoteDriver(
remoteServerAddr = "localhost",
port = 4445L,
browserName = "firefox"
)
library(RSelenium)
remDr <- remoteDriver(
remoteServerAddr = "localhost",
port = 4445L,
browserName = "firefox"
)
remDr$open()
remDr <- remoteDriver(
remoteServerAddr = "localhost",
port = 4445L,
browserName = "firefox"
)
remDr$open()
?remoteDriver
RSelenium::checkForServer()
shell('docker pull selenium/standalone-firefox')
system('docker pull selenium/standalone-firefox')
## running selenium in Docker (https://stackoverflow.com/questions/45395849/cant-execute-rsdriver-connection-refused)
#system('docker pull selenium/standalone-firefox') # only need to do this once
system('docker run -d -p 4445:4444 selenium/standalone-firefox')
remDr <- remoteDriver(remoteServerAddr = "localhost", port = 4445L, browserName = "firefox'")
remDr$open()
remDr <- remoteDriver(remoteServerAddr = "4445:4444", port = 4445L, browserName = "firefox'")
remDr$open()
?remoteDriver
## running selenium in Docker (https://stackoverflow.com/questions/45395849/cant-execute-rsdriver-connection-refused)
#system('docker pull selenium/standalone-firefox') # only need to do this once
system('docker run -d -p 0.0.0.0 selenium/standalone-firefox')
system('docker run --help')
## running selenium in Docker (https://stackoverflow.com/questions/45395849/cant-execute-rsdriver-connection-refused)
#system('docker pull selenium/standalone-firefox') # only need to do this once
system('docker run -d -p selenium/standalone-firefox')
## running selenium in Docker (https://stackoverflow.com/questions/45395849/cant-execute-rsdriver-connection-refused)
#system('docker pull selenium/standalone-firefox') # only need to do this once
system('docker run -d -p 127.0.0.1::80 selenium/standalone-firefox')
remDr <- remoteDriver(remoteServerAddr = "localhost", port = 4445L, browserName = "firefox'")
remDr <- remoteDriver(remoteServerAddr = "localhost", port = 127.0.0.1::80, browserName = "firefox'")
remDr <- remoteDriver(remoteServerAddr = "localhost", port = '127.0.0.1::80', browserName = "firefox'")
remDr <- remoteDriver(remoteServerAddr = "localhost", port = 80, browserName = "firefox'")
remDr$open()
library(rvest)
library(xml)
library(xml2)
ht <- read_html()
example_url <- 'https://www.rightmove.co.uk/property-for-sale/find.html?locationIdentifier=POSTCODE%5E1245621&radius=0.5&sortType=6&propertyTypes=&mustHave=&dontShow=&furnishTypes=&keywords='
ht <- read_html(example_url)
str(ht)
body_nodes <- ht %>%
html_node(“body”) %>%
html_children()
library(rvest)
library(xml2)
?html_children
body_nodes <- ht %>%
html_node(“body”)
?html_node
body_nodes <- ht %>%
html_node('body') %>%
html_children()
body_nodes
body_nodes %>% html_children()
ht %>%
rvest::html_nodes('body') %>%
xml2::xml_find_all("//span[contains(@class, 'searchFilters')]") %>%
rvest::html_text()
ht %>%
rvest::html_nodes('body') %>%
xml2::xml_find_all("//span[contains(@id, 'searchFilters')]") %>%
rvest::html_text()
?xml_find_all
ht
string(ht)
as.character(ht)
as.character(ht) %>% nchar()
library(stringr)
?str_locate
cht <- as.character(ht)
str_locate(cht, 'searchFilters')
install.packages('webshot')
webshot::install_phantomjs()
webshot::webshot(example_url, 'www/site.png')
getwd()
library(tesseract)
install.packages('tesseract')
?magick::image_crop
install.packages('magick')
?image_crop
magick::image_read('www/site.png') %>%
magick::image_crop(frink, "100x150+50")
magick::image_read('www/site.png') %>%
magick::image_crop( "100x150+50")
magick::image_read('www/site.png') %>%
magick::image_crop( "100x150")
?magick::image_cro
?p
?magick::image_crop
magick::image_read('www/site.png') %>%
magick::image_crop( "100x150")
magick::image_read('www/site.png') %>%
magick::image_crop( "120x60")
magick::image_read('www/site.png') %>%
magick::image_crop( "120x60") %>%
tesseract::ocr(engine = eng)
magick::image_read('www/site.png') %>%
magick::image_crop( "120x60") %>%
tesseract::ocr()
magick::image_read('www/site.png') %>%
magick::image_crop( "120x60") %>%
tesseract::ocr() %>%
stringr::str_replace_all("\\b[a-z]+\\b", "")
magick::image_read('www/site.png') %>%
magick::image_crop( "120x60") %>%
tesseract::ocr() %>%
stringr::str_replace_all("[a-z]", "")
?isupper
magick::image_read('www/site.png') %>%
magick::image_crop( "120x60") %>%
tesseract::ocr() %>%
stringr::str_replace_all("^[:upper:]+$")
magick::image_read('www/site.png') %>%
magick::image_crop( "120x60") %>%
tesseract::ocr() %>%
stringr::str_detect("^[:upper:]+$")
s <- magick::image_read('www/site.png') %>%
magick::image_crop( "120x60") %>%
tesseract::ocr()
gsub("\\\\", "", s)
gsub("\\", "", s)
library(stringi)
stringi::stri_unescape_unicode( s)
gregexpr("[A-Z]", s)
gregexpr("[A-Z]", s)[[1]]
gregexpr("[A-Z]", s)[[1]][1]
gregexpr("[A-Z]", s)[[1]]%>%class()
gregexpr("[A-Z]", s)[[1]]%>%names()
gregexpr("[A-Z]", s)
gregexpr("[A-Z]", s)%>% class()
gregexpr("[A-Z]", s)%>% names()
gregexpr("[A-Z]", s)[[1]]
length(gregexpr("[A-Z]", s)[[1]])
gregexpr("[A-Z]", s)[[1]][2]
gregexpr("[A-Z]", s)[[1]][4]
stringi::stri_unescape_unicode( s)
matches <- gregexpr("[A-Z]", s)[[1]]
final_letter_of_interest <- matches[length(matches)]
s[1:final_letter_of_interest]
s
substr(s, 1, final_letter_of_interest)
code_used <- 1245621
get_postcode_from_code(1245621)
get_postcode_from_code <- function(code_used) {
query_url <- paste0('https://www.rightmove.co.uk/property-for-sale/find.html?locationIdentifier=POSTCODE%5E',
code_used,
'&radius=0.5&sortType=6&propertyTypes=&mustHave=&dontShow=&furnishTypes=&keywords=')
#
webshot::webshot(query_url, 'www/site.png')  # https://www.listendata.com/2018/05/take-screenshot-of-webpage-using-r.html
s <- magick::image_read('www/site.png') %>%
magick::image_crop( "120x60") %>%
tesseract::ocr() %>%
stringr::str_detect("^[:upper:]+$")
matches <- gregexpr("[A-Z]", s)[[1]]
final_letter_of_interest <- matches[length(matches)]
postcode <- substr(s, 1, final_letter_of_interest)
postcode
}
get_postcode_from_code(1245621)
query_url <- paste0('https://www.rightmove.co.uk/property-for-sale/find.html?locationIdentifier=POSTCODE%5E',
code_used,
'&radius=0.5&sortType=6&propertyTypes=&mustHave=&dontShow=&furnishTypes=&keywords=')
#
webshot::webshot(query_url, 'www/site.png')  # https://www.listendata.com/2018/05/take-screenshot-of-webpage-using-r.html
s <- magick::image_read('www/site.png') %>%
magick::image_crop( "120x60") %>%
tesseract::ocr() %>%
stringr::str_detect("^[:upper:]+$")
matches <- gregexpr("[A-Z]", s)[[1]]
final_letter_of_interest <- matches[length(matches)]
postcode <- substr(s, 1, final_letter_of_interest)
postcode
}
final_letter_of_interest
s
code_used <- 1245621
get_postcode_from_code <- function(code_used) {
query_url <- paste0('https://www.rightmove.co.uk/property-for-sale/find.html?locationIdentifier=POSTCODE%5E',
code_used,
'&radius=0.5&sortType=6&propertyTypes=&mustHave=&dontShow=&furnishTypes=&keywords=')
#
webshot::webshot(query_url, 'www/site.png')  # https://www.listendata.com/2018/05/take-screenshot-of-webpage-using-r.html
s <- magick::image_read('www/site.png') %>%
magick::image_crop( "120x60") %>%
tesseract::ocr()
matches <- gregexpr("[A-Z]", s)[[1]]
final_letter_of_interest <- matches[length(matches)]
postcode <- substr(s, 1, final_letter_of_interest)
postcode
}
get_postcode_from_code(1245621)
postcode_lsoa_lookup <-
fread("raw_data/PCD_OA_LSOA_MSOA_LAD_AUG21_UK_LU.csv",
data.table = F)
names(postcode_lsoa_lookup)
postcode_lsoa_lookup<- postcode_lsoa_lookup %>% select(pcds, lsoa11cd)
object.size(postcode_lsoa_lookup)
dim(postcode_lsoa_lookup)
df <- fread('data/all_data_lsoa.csv', data.table = F) %>%
filter(commute_hours <= 2.5,
price <= 500000)
dim(Df)
dim(df)
postcode_lsoa_lookup <-
fread("raw_data/PCD_OA_LSOA_MSOA_LAD_AUG21_UK_LU.csv",
data.table = F) %>%
select(pcds, lsoa11cd) %>%
filter(lsoa11cd %in% df$lsoa11cd)
dim(postcode_lsoa_lookup)
head(df)
acceptable_postcodes <- postcode_lsoa_lookup %>% filter(lsoa11cd == postcode_lsoa_lookup) %>% pull(pcds)
acceptable_postcodes
View(postcode_lsoa_lookup)
acceptable_postcodes <- postcode_lsoa_lookup %>% filter(lsoa11cd == lsoa_of_choice) %>% pull(pcds)
acceptable_postcodes
lsoa_of_choice <- 'E01000007'
acceptable_postcodes <- postcode_lsoa_lookup %>% filter(lsoa11cd == lsoa_of_choice) %>% pull(pcds)
acceptable_postcodes
pos_of_first_acceptable_postcode <- which(postcode_lsoa_lookup$pcds == acceptable_postcodes[1])
pos_of_first_acceptable_postcode
pos_of_first_acceptable_postcode <- which(postcode_lsoa_lookup$pcds == acceptable_postcodes[1]) / nrow(postcode_lsoa_lookup)
tail(postcode_lsoa_lookup)
postcode_lsoa_lookup %>% filter(substr(pcds, 1, 1) != "W") %>% dim()
postcode_lsoa_lookup[601000,]
initial_point <- pos_of_first_acceptable_postcode * 1.5 * 10^6
initial_point
initial_point <- round(pos_of_first_acceptable_postcode * 1.5 * 10^6)
initial_point <- pos_of_first_acceptable_postcode * 1.5 * 10^6
initial_point <- round(pos_of_first_acceptable_postcode * 1.5 * 10^6)
initial_point
initial_point <- round(pos_of_first_acceptable_postcode * 1.5 * 10^6, 0)
initial_point
?tryCatch
returned_postcode <- tryCatch({get_postcode_from_code(candidate_value)},
error = "")
returned_postcode
returned_postcode
candidate_value <- round(pos_of_first_acceptable_postcode * 1.5 * 10^6, 0)
returned_postcode <- tryCatch({get_postcode_from_code(candidate_value)},
error = "")
returned_postcode
head(df)
head(postcode_lsoa_lookup)
postcode_lsoa_lookup[3001,]
i = 1
10^6 + 3000*i + round(runif(1, 0, 2000))
i % 100 =
i % 100
i %% 100
## Just exploring for now
i <- 1
value_store <- rep(0, 10 ^ 4)
postcode_store <- rep(0, 10 ^ 4)
while (T) {
candidate_value <- 10 ^ 6 + 3000 * i + round(runif(1, 0, 2000))
returned_postcode <-
tryCatch({
get_postcode_from_code(candidate_value)
},
error = "")
print(returned_postcode)
value_store[i] <- candidate_value
postcode_store[i] <- returned_postcode
i <- i + 1
if (i %% 100 == 2) {
fwrite(data.frame(cand = value_store, postcode = postcode_store),
'out.csv')
}
if (i > 4000) {
i = 1
}
}
i
while (T) {
candidate_value <- 10 ^ 6 + 3000 * i + round(runif(1, 0, 2000))
returned_postcode <-
tryCatch({
get_postcode_from_code(candidate_value)
},
error = "")
print(returned_postcode)
value_store[i] <- candidate_value
postcode_store[i] <- returned_postcode
i <- i + 1
if (i %% 100 == 2) {
fwrite(data.frame(cand = value_store, postcode = postcode_store),
'out.csv')
}
if (i > 1300) {
i = 1
}
}
i
length(value_store)
length(postcode_store)
tail(postcode_store)
table(postcode_store)
table(postcode_store)== 'O'
table(postcode_store)== 'O'[table(postcode_store)== 'O']
d <- data.frame(cand = value_store, postcode = postcode_store)
head(d)
tail(d)
d <- d %>% filter(cand > 0.1)
dim(d)
head(d)
i <- 1
iter_row_store <- 1
value_store <- rep(0, 10 ^ 5)
postcode_store <- rep(0, 10 ^ 5)
while (T) {
candidate_value <- 10 ^ 6 + 3000 * i + round(runif(1, 0, 2000))
returned_postcode <-
tryCatch({
get_postcode_from_code(candidate_value)
},
error = "")
print(returned_postcode)
value_store[iter_row_store] <- candidate_value
postcode_store[iter_row_store] <- returned_postcode
iter_row_store <- iter_row_store + 1
i <- i + 1
if (i %% 100 == 2) {
fwrite(data.frame(cand = value_store, postcode = postcode_store),
'out.csv')
}
if (i > 1300) {
i <- 1
}
}
i
iter_row_store
while (T) {
candidate_value <- 10 ^ 6 + 3000 * i + round(runif(1, 0, 2000))
returned_postcode <-
tryCatch({
get_postcode_from_code(candidate_value)
},
error = "")
print(returned_postcode)
value_store[iter_row_store] <- candidate_value
postcode_store[iter_row_store] <- returned_postcode
iter_row_store <- iter_row_store + 1
i <- i + 1
if (i %% 100 == 2) {
fwrite(data.frame(cand = value_store, postcode = postcode_store),
'out.csv')
}
if (i > 1300) {
i <- 1
}
}
# estimating size of jump between
i
iter_row_store
while (T) {
candidate_value <- 10 ^ 6 + 3000 * i + round(runif(1, 0, 2000))
returned_postcode <-
tryCatch({
get_postcode_from_code(candidate_value)
},
error = "")
print(returned_postcode)
value_store[iter_row_store] <- candidate_value
postcode_store[iter_row_store] <- returned_postcode
iter_row_store <- iter_row_store + 1
i <- i + 1
if (i %% 100 == 2) {
fwrite(data.frame(cand = value_store, postcode = postcode_store),
'out.csv')
}
if (i > 1300) {
i <- 1
}
}
iter_row_store
value_store
tail(value_store)
tail(postcode_store)
fwrite(data.frame(cand = value_store, postcode = postcode_store),
'out.csv')
# on using BEST for Bayesian t.tests: https://cran.r-project.org/web/packages/BEST/vignettes/BEST.pdf
library(BEST)
library(dplyr)
setwd("~/Desktop/Work/BESTmcmc_covidSamHilton")
df <- data.table::fread("for_best.csv", data.table = F)
had_plan <- df %>% filter(any_plan == "plan") %>% pull(total_deaths)
no_plan <- df %>% filter(any_plan == "no_plan") %>% pull(total_deaths)
res <- BESTmcmc(had_plan, no_plan)
plot(res, compVal=0)  # view initial plot with HDI
plot(res, compVal=0, ROPE=c(-2000, -500)) # 62% chance of being >500 deaths/mill if no plan
summary(res, ROPEm = c(-2000, 0)) # shows % in ROPE
plotPostPred(res) # view posterior predictions from random steps in mcmc chain, along with data histogram
plotAll(res) # view all charts in one image
dim(df)
head(df)
res <- BESTmcmc(had_plan, no_plan)
plot(res, compVal=0)  # view initial plot with HDI
plot(res, compVal=0, ROPE=c(-2000, -500)) # 62% chance of being >500 deaths/mill if no plan
summary(res, ROPEm = c(-2000, 0)) # shows % in ROPE
plotPostPred(res) # view posterior predictions from random steps in mcmc chain, along with data histogram
plotAll(res) # view all charts in one image
